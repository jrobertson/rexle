
Examples
--------

require 'rexle'

# 1) return the element which matches @colour='red'
s = "<a>ddd<trust colour='red'>abc</trust><trust>fff</trust></a>"
doc = Rexle.new s
r = doc.xpath "trust[@colour='red']"
r.value
#=> abc

# 2) return the element value and attributes 
s = "<a>ddd<trust colour='red'>abc</trust><trust colour='blue'>fff</trust><trust colour='purple'>ggg</trust></a>"
doc = Rexle.new s
r = doc.xpath "trust[@colour='red']"
r.value
#=> abc

r.attributes
#=> {"colour"=>"red"}

# 3) multiple elements returned which match @colour='red'
s = "<a>ddd<trust colour='red'>abc</trust><trust colour='blue'>fff</trust><trust colour='red'>ggg</trust></a>"
doc = Rexle.new s
puts doc.xpath("trust[@colour='red']").map(&:value).join(',')
#=> abc,ggg

# 4) single element returned
s = "<a>ddd<trust>abc</trust><ccc>rrr</ccc></a>"
Rexle.new(s).xpath('trust').value
#=> abc

# 5) nested elements
s = "<a>ddd<trust>abc</trust><ccc><eee>fff</eee></ccc></a>"
Rexle.new(s).xpath('ccc/eee').value
#=> "fff"

# 6) multiple elements returned
s = "<a>ddd<trust>abc</trust><trust>ee3</trust><ccc>rrr</ccc></a>"
puts Rexle.new(s).xpath('trust').map(&:value).join(',')
#=> abc,ee3

# 7) //trust
s = "<a>ddd<trust colour='red'>abc</trust><trust>fff</trust></a>"
puts Rexle.new(s).xpath("//trust").map(&:value).join(',')
#=> abc,fff

# 8) count()
s = "<a>ddd<trust colour='red'>abc</trust><trust>fff</trust></a>"
puts Rexle.new(s).xpath "count(trust)"
#=> 2

# 9) attribute function with id
s = "<a id='fuzz'>ddd<trust colour='red'>abc</trust><trust>fff</trust></a>"
Rexle.new(s).xpath "attribute::id"
#=> fuzz

# 10) element selection by index
s = "<a id='fuzz'>ddd<trust colour='red'>abc</trust><trust>fff</trust></a>"
puts Rexle.new(s).xpath("trust[1]").value
#=> abc

# 11) select 1 descendent which matches //trust[@colour='red']
s = "<a>ddd<trust colour='red'>abc</trust><trust>fff</trust></a>"
doc = Rexle.new(s)
doc.xpath("//trust[@colour='red']").value
#=> abc

# 12) select 2 mixed descendents which match //trust[@colour='red']
s = "<a>ddd<trust colour='red'>abc</trust><trust>fff<e><trust colour='red'>rrr</trust></e></trust></a>"
doc = Rexle.new(s)
doc.xpath("//trust[@colour='red']").map(&:value).join(',')
#=> abc,rrr

# 13) select the text value from an XPath 2 elements deep
s = "<a id='fuzz'>ddd<summary><a>fff<a/></summary></a>"
doc = Rexle.new s
r = doc.xpath "summary/a/text()"
#=> fff

# 14) mixed xpath: descendant and index
s = "<a>ddd<trust>abc</trust><ccc><eee>fff</eee><eee>ggg</eee></ccc></a>"
doc = Rexle.new s
r = doc.xpath "ccc/eee[2]"
#=> ggg

# 15) multiple descendant elements returned from text()
s = "<root>ddd<a><trust>abc</trust><trust>ee3</trust><ccc>rrr</ccc></a></root>"
doc = Rexle.new(s)
r = doc.xpath("a/trust/text()")
#=> abc,ee3

# 16) a wildcard followed by a single element attribute
s = "<root>ddd<a><trust id='45'>abc</trust></a></root>"
doc = Rexle.new(s)
r = doc.xpath('a/*/attribute::id')
#=> 45

# 17) a wildcard followed by a pair of element attributes
s = "<root>ddd<a><trust id='45'>abc</trust><ccc id='66'>rrr</ccc></a></root>"
doc = Rexle.new(s)
r = doc.xpath('a/*/attribute::id')
#=> 45, 66

# 18) a wildcard followed by a single element attribute from a possible pair
require '/home/james/learning/ruby/rexle'
s = "<root>ddd<a><trust id='45'>abc</trust><ccc>rrr</ccc></a></root>"
doc = Rexle.new(s)
r = doc.xpath('a/*/attribute::id')
#=> 45

# 19) descendant with predicate
s = "<root>ddd<a><trust id='45'>abc</trust><ccc>rrr</ccc></a></root>"
puts Rexle.new(s).xpath("a/trust[@id='45']").value
#=> abc

# 20) descendant with wildcard and predicate
s = "<root>ddd<a><trust id='45'>abc</trust><ccc>rrr</ccc></a></root>"
puts Rexle.new(s).xpath("a/*[@id='45']").value
#=> abc

# 21) descendant with wildcard
s = "<root>ddd<a><trust id='45'>abc</trust><ccc>rrr</ccc></a></root>"
Rexle.new(s).xpath("a/*").map(&:value).join(',')
#=> abc,rrr

# 22) descendant with wildcard and no 2nd element value
s = "<root>ddd<a><trust id='45'>abc</trust><ccc></ccc></a></root>"
Rexle.new(s).xpath("a/*").map(&:value).join(',')
#=> 45,

# 23) descendant 3 levels deep
s = "<root>ddd<a><trust id='45' colour='red'>abc<b>4444</b></trust><ccc><d>tttt</d></ccc></a></root>"
Rexle.new(s).xpath("a/trust/b").value
#=> 4444

# 24) descendant 3 levels deep with wildcard and predicate
s = "<root>ddd<a><trust id='45' colour='red'>abc<b>4444</b></trust><ccc><d>tttt</d></ccc></a></root>"
Rexle.new(s).xpath("a/*[@colour='red']/b").value
#=> 4444

# 25) descendant with wildcard and predicate followed by another wildcard
s = "<root>ddd<a><trust id='45' colour='red'>abc<b>4444</b></trust><ccc><d>tttt</d></ccc></a></root>"
Rexle.new(s).xpath("a/*[@colour='red']/*")
#=> 4444

# 26) 2 wildcard descendants from different branches with the same predicate followed by another wildcard
s = "<root>ddd<a><trust id='45' colour='red'>abc<b>4444</b></trust><ccc colour='red'><d>tttt</d></ccc></a></root>"
Rexle.new(s).xpath("a/*[@colour='red']/*") 
#=> 4444,tttt

# 27) mixed descendant wildcards with text()
s = "<root>ddd<a><trust id='45' colour='red'>abc<b>4444</b></trust><ccc><d>tttt</d></ccc></a></root>"
doc = Rexle.new(s).xpath("a/*[colour='red']/*/text()")
#=> 4444

# 28) descendant with wildcard and index predicate
s = "<root>ddd<a><trust id='45' colour='red'>abc<b>4444</b></trust><ccc><d>tttt</d></ccc></a></root>"
Rexle.new(s).xpath("a/*[2]")
#=> ccc

# 29) single wildcard
s = "<root>ddd<a><trust id='45'>abc</trust></a></root>"
Rexle.new(s).xpath('*')
#=> a

# 30) wildcard with 2 elements returned
s = "<root>ddd<a><trust id='45'>abc</trust></a><f>yyy</f></root>"
doc = Rexle.new(s).xpath('*')
#=> a,f

# 31) nested XPath enumeration
s = "<root>ddd<a><trust id='45'>abc</trust></a><f><b>yyy</b></f><g><b>t4t4</b></g></root>"
Rexle.new(s).xpath('*').map {|x| x.xpath('b').map(&:value)}\
  .select{|x| x.length > 0}.join(',')
#=> "yyy,t4t4"

# 32) validate typical XML
urls =<<URL
<urls><summary><recordx_type>dynarex</recordx_type><format_mask>[!short_url] [!full_url]</format_mask><schema>urls/url(short_url,full_url)</schema></summary><records><url created="2010-10-11 21:11:16 +0100" id="2" last_modified="2010-10-13 15:20:58 +0100"><short_url>aa</short_url><full_url>http://www.wired.com/</full_url></url></records></urls>
URL
doc = Rexle.new(urls)

# 33) validate XML containing newline characters
require '/home/james/learning/ruby/rexle'

urls =<<URL
<urls>
  <summary><recordx_type>dynarex</recordx_type><format_mask>[!short_url] [!full_url]</format_mask>
    <schema>urls/url(short_url,full_url)</schema>
  </summary><records><url created="2010-10-11 21:11:16 +0100" id="2" last_modified="2010-10-13 15:20:58 +0100">      <short_url>aa</short_url><full_url>http://www.wired.com/</full_url></url></records></urls>
URL
doc = Rexle.new(urls)

# 34) support for !=
buffer = "<root><s><f colour='blue'/><f colour='red'>rrr</f><f colour='red'>ttt</f></s><a></a></root>"
a = Rexle.new(buffer)
a.xpath("//f[@colour!='blue']").map(&:value)

# 35) element predicate
buffer ="<root><s><f colour='blue'/><f colour='red'>rrr</f><f colour='red'>ttt</f></s><a></a></root>"
Rexle.new(buffer).xpath("s[f='rrr']")[0].name

# 36) element predicate with attribute id returned 
buffer ="<root><s id='1'><f colour='red'>ttt</f></s><a></a><s id='2'><f colour='red'>rrr</f></s></root>"
r = Rexle.new(buffer).xpath("*[f='rrr']")[0].attributes['id']
#=> 2

# 37) element predicate using !=  with attribute id returned 
buffer ="<root><s id='1'><f colour='red'>ttt</f></s><a></a><s id='2'><f colour='red'>rrr</f></s></root>"
r = Rexle.new(buffer).xpath("*[f!='rrr']")[0].attributes['id']
#=> 1

# 38)
buffer ="<root><s id='1'><f colour='red'></f></s><a></a><s id='2'><f colour='red'>rrr</f></s></root>"
r = Rexle.new(buffer).xpath("*[f='rrr']")[0].attributes['id']
#=> 1

# 39) nested element with self matching predicate
xml =<<XML
<urls>
  <summary>
    <recordx_type>dynarex</recordx_type>
    <format_mask>[!full_url] [!short_url]</format_mask>
    <schema>urls/url(full_url, short_url)</schema>
  </summary>
  <records>
    <url><full_url>weeb</full_url><short_url>dfs</short_url></url>
    <url><full_url>red</full_url><short_url>gr</short_url></url>
    <url><full_url>green</full_url><short_url>yw</short_url></url>
    <url><full_url></full_url><short_url>nb</short_url></url>
    <url><full_url></full_url><short_url>jh</short_url></url>
  </records>
</urls>
XML

rexle = Rexle.new(xml)
a = rexle.xpath("records/url/full_url[.!='']/text()")
#=> ["weeb", "red", "green"]


# 40) xpath using block

xml =<<XML
<urls>
  <summary>
    <recordx_type>dynarex</recordx_type>
    <format_mask>[!full_url] [!short_url]</format_mask>
    <schema>urls/url(full_url, short_url)</schema>
  </summary>
  <records>
    <url><full_url>weeb</full_url><short_url>dfs</short_url></url>
    <url><full_url>red</full_url><short_url>gr</short_url></url>
    <url><full_url>green</full_url><short_url>yw</short_url></url>
    <url><full_url></full_url><short_url>nb</short_url></url>
    <url><full_url></full_url><short_url>jh</short_url></url>
  </records>
</urls>
XML

rexle = Rexle.new(xml)
a = rexle.xpath("records/url"){|e| %w(full_url short_url).map{|x| e.text(x)}}
#=> [["weeb", "dfs"], ["red", "gr"], ["green", "yw"], ["", "nb"], ["", "jh"]]

# 41) multiple elements with predicate using or
s = "<root>ddd<a><trust id='45' colour='red'>abc<b>4444</b></trust><ccc colour='blue'>fff</ccc><trust id='48' colour='red'>yyy</trust></a></root>"
doc = Rexle.new(s)
a = doc.xpath("a/*[@colour='red' or @colour='blue']") 